lab:01
#include <stdio.h>
#include <stdlib.h>

struct Day {
    char dayName[20];
    int date;
    char activity[100];
};

void create(struct Day *day) {
    printf("Enter the day name: ");
    scanf("%s", day->dayName);

    printf("Enter the date: ");
    scanf("%d", &day->date);

    printf("Enter the activity for the day: ");
    scanf(" %[^\n]s", day->activity);
}

void read(struct Day *calendar, int size) {
    for (int i = 0; i < size; i++) {
        printf("Enter details for Day %d:\n", i + 1);
        create(&calendar[i]);
    }
}

void display(struct Day *calendar, int size) {
    printf("\nWeek's Activity Details:\n");
    for (int i = 0; i < size; i++) {
        printf("Day %d:\n", i + 1);
        printf("Day Name: %s\n", calendar[i].dayName);
        printf("Date: %d\n", calendar[i].date);
        printf("Activity: %s\n\n", calendar[i].activity);
    }
}

int main() {
    int size;
    printf("Enter the number of days in the week: ");
    scanf("%d", &size);

    struct Day *calendar = (struct Day *)malloc(sizeof(struct Day) * size);
    if (!calendar) {
        printf("Memory allocation failed. Exiting program.\n");
        return 1;
    }

    read(calendar, size);
    display(calendar, size);

    free(calendar);
    return 0;
}

lab:02
#include<stdio.h>

char str[50], pat[20], rep[20], res[50];
int c = 0, m = 0, i = 0, j = 0, k, flag = 0;
void stringmatch()
{
    while (str[c] != '\0')
    {
        if (str[m] == pat[i])
        {
            i++;
            m++;
            if (pat[i] == '\0')
            {
                flag = 1;
                for (k = 0; rep[k] != '\0'; k++, j++)
                {
                    res[j] = rep[k];
                }
                i = 0;
                c = m;
            }
        }
        else
        {
            res[j] = str[c];
            j++;
            c++;
            m = c;
            i = 0;
        }
    }
    res[j] = '\0';
}
void main()
{
    printf("Enter the main string:");
    gets(str);
    printf("\nEnter the pat string:");
    gets(pat);
    printf("\nEnter the replace string:");
    gets(rep);
    printf("\nThe string before pattern match is:\n %s", str);
    stringmatch();
    if (flag == 1)
        printf("\nThe string after pattern match and replace is: \n %s ", res);
    else
        printf("\nPattern string is not found");
}

lab:03
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#define MAX 4

bool StkFull(int top) {
    return top == MAX - 1;
}

bool StkEmpty(int top) {
    return top == -1;
}

void Push(int stack[], int elem, int *top) {
    stack[++(*top)] = elem;
}

int Pop(int stack[], int *top) {
    return stack[(*top)--];
}

void Display(int stack[], int top) {
    printf("\nStack Elements:\n");
    for (int i = top; i >= 0; i--)
        printf("| %d |\n", stack[i]);
}

int Peek(int stack[], int top) {
    return stack[top];
}

bool Palindrome(int num) {
    int original = num, reverse = 0, remainder;
    while (num > 0) {
        remainder = num % 10;
        reverse = reverse * 10 + remainder;
        num /= 10;
    }
    return original == reverse;
}

int main(void) {
    int stack[MAX], top = -1;
    int elem, choice;

    for (;;) {
        printf("\nSTACK OPERATIONS\n");
        printf("====================");
        printf("\n 1. Push\n 2. Pop\n 3. Display\n 4. Peek\n 5. Check Palindrome\n 6. Demonstrate Overflow\n");
        printf(" 7. Demonstrate Underflow\n 8. Exit\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                if (!StkFull(top)) {
                    printf("Enter element to push: ");
                    scanf("%d", &elem);
                    Push(stack, elem, &top);
                } else {
                    printf("Stack Overflow\n");
                }
                break;

            case 2:
                if (!StkEmpty(top)) {
                    elem = Pop(stack, &top);
                    printf("Popped Element: %d\n", elem);
                } else {
                    printf("Stack Underflow\n");
                }
                break;

            case 3:
                if (!StkEmpty(top)) {
                    Display(stack, top);
                } else {
                    printf("Stack is Empty\n");
                }
                break;

            case 4:
                if (!StkEmpty(top)) {
                    elem = Peek(stack, top);
                    printf("Element at the Top: %d\n", elem);
                } else {
                    printf("Stack is Empty\n");
                }
                break;

            case 5:
                printf("Enter a number to check palindrome: ");
                scanf("%d", &elem);
                if (Palindrome(elem)) {
                    printf("%d is a Palindrome\n", elem);
                } else {
                    printf("%d is not a Palindrome\n", elem);
                }
                break;

            case 6:
                if (!StkFull(top)) {
                    printf("Push elements to demonstrate overflow:\n");
                    while (!StkFull(top)) {
                        printf("Enter an element: ");
                        scanf("%d", &elem);
                        Push(stack, elem, &top);
                    }
                    printf("Stack Overflow Demonstrated\n");
                } else {
                    printf("Stack is already full\n");
                }
                break;

            case 7:
                if (!StkEmpty(top)) {
                    printf("Pop elements to demonstrate underflow:\n");
                    while (!StkEmpty(top)) {
                        elem = Pop(stack, &top);
                        printf("Popped Element: %d\n", elem);
                    }
                    printf("Stack Underflow Demonstrated\n");
                } else {
                    printf("Stack is already empty\n");
                }
                break;

            case 8:
                exit(0);

            default:
                printf("Invalid Choice. Try again.\n");
        }
    }

    return 0;
}



lab:05b
#include <stdio.h>

void tower(int n, int source, int temp, int destination)
{
    if (n == 0)
        return;
    tower(n - 1, source, destination, temp);
    printf("\nMove disc %d from %c to %c", n, source, destination);
    tower(n - 1, temp, source, destination);
}
void main()
{
    int n;
    printf("\nEnter the number of discs: \n");
    scanf("%d", & n);
    tower(n, 'A', 'B', 'C');
    printf("\n\nTotal Number of moves are: %d", (int) pow(2, n) - 1);
}

lab=06
#include<stdio.h>
#define MAX 5

char queue[MAX];
int front = -1, rear = -1;

int isEmpty() { return front == -1; }
int isFull() { return (rear + 1) % MAX == front; }

void insert(char element) {
    if (isFull()) return (void)printf("Queue Overflow\n");
    if (isEmpty()) front = rear = 0;
    else rear = (rear + 1) % MAX;
    queue[rear] = element;
}

void delete() {
    if (isEmpty()) return (void)printf("Queue Underflow\n");
    if (front == rear) front = rear = -1;
    else front = (front + 1) % MAX;
}

void display() {
    if (isEmpty()) return (void)printf("Queue is empty\n");
    for (int i = front;; i = (i + 1) % MAX) {
        printf("%c ", queue[i]);
        if (i == rear) break;
    }
    printf("\n");
}

int main() {
    int choice;
    char element;
    while (1) {
        printf("\n1.Insert \n2.Delete \n3.Display \n4.Exit \n");
        printf("Enter your choice:");
        scanf("%d", &choice);
        if (choice == 4) break;
        if (choice == 1) {
            printf("Enter element: ");
            scanf(" %c", &element);
            insert(element);
        } else if (choice == 2) delete();
        else if (choice == 3) display();
        else printf("Invalid choice\n");
    }
    return 0;
}

lab:10
#include <stdio.h>
#include <stdlib.h>

struct BST {
    int data;
    struct BST *lchild, *rchild;
};
typedef struct BST *NODE;

NODE create() {
    NODE temp = (NODE)malloc(sizeof(struct BST));
    printf("Enter value: ");
    scanf("%d", &temp->data);
    temp->lchild = temp->rchild = NULL;
    return temp;
}

void insert(NODE root, NODE newnode) {
    if (newnode->data < root->data) {
        if (root->lchild) insert(root->lchild, newnode);
        else root->lchild = newnode;
    } else if (newnode->data > root->data) {
        if (root->rchild) insert(root->rchild, newnode);
        else root->rchild = newnode;
    }
}

void search(NODE root) {
    if (!root) return (void)printf("Tree is empty.\n");
    int key;
    printf("Enter element to search: ");
    scanf("%d", &key);
    while (root) {
        if (key == root->data) return (void)printf("Element found.\n");
        root = key < root->data ? root->lchild : root->rchild;
    }
    printf("Element not found.\n");
}

void traverse(NODE root, int type) {
    if (!root) return;
    if (type == 1) printf("%d ", root->data);           
    traverse(root->lchild, type);
    if (type == 2) printf("%d ", root->data);           
    traverse(root->rchild, type);
    if (type == 3) printf("%d ", root->data);           
}

int main() {
    NODE root = NULL, newnode;
    int ch, n, i;
    while (1) {
        printf("\n1.Create 2.Search 3.Traversals 4.Exit\nEnter choice: ");
        scanf("%d", &ch);
        if (ch == 4) break;
        switch (ch) {
            case 1:
                printf("Number of elements: ");
                scanf("%d", &n);
                for (i = 0; i < n; i++) {
                    newnode = create();
                    root = root ? root : newnode;
                    if (root != newnode) insert(root, newnode);
                }
                break;
            case 2:
                search(root);
                break;
            case 3:
                printf("Preorder: "); traverse(root, 1); printf("\n");
                printf("Inorder: "); traverse(root, 2); printf("\n");
                printf("Postorder: "); traverse(root, 3); printf("\n");
                break;
            default:
                printf("Invalid choice.\n");
        }
    }
    return 0;
}




